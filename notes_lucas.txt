slide 2
    - Can we use machines to systematically expand our logical theories?
    - Do we even need people for thinking and proving?
    - What is decidability and what does it have to do with the question?
    
slide 5
    - "free variable" is a variable without quantifier
    - emphasis: this does not yet mean anything, it's just a well-formed expression
    
slide 6
    - here we add meaning (goal: make this say "There are infinitely many prime numbers.")

slide 7
    - start at START STATE q_0
    - What could the first bit vector of an addition look like?
    - What are the valid ones (transition to q_1)? For which do we have to check if the following bit gives a carry (transition to q_2)?
    - throw away others (q_3)
    - have a look at all possible following bits
    
    - non-deterministic, here: missing transitions from q_3 (easy to complete), general:
        - states have multiple outgoing transitions to different states with the same character
        - not all states must have all transitions
        - empty word can be transition character
        
slide 10
    - "(almost)" because () will act as an empty input vector
    - let's review automata:
        - formally introduce -> quite a bit of work, worth your while
        - here: basic concept
    
slide 11
    - "state machines"
    - (finite) number of states: q_0, ..., q_3
    - machine occupies exactly one state
    - transitions, labeled with characters: 
        -> you are in a state (q_0)
        -> read character (0,0,0) 
        -> move along corresponding transition (land in q_1)
    - issues with expression "automaton reads character" 
        - from where? who inputs?
        - abstractly: ex. word, automaton moves along c by c from left to right
    - clue: label states as special ("final states")
        - which words take us from q_0 to q_1 ("accepted words")
        - structure of automaton distinguishes
        - this is designed to accept valid add. of |N enc. in S_3
            - (0,0,0) valid
            - (0,0,1) carry bit
            - (1,0,0) incorrect
            
slide 13:
    - important: anything we said so far can be mechanized, does not require thinking
    - there are rules:
        - will not write them down (time / no use for concept)
        - algorithm (= set of rules) can construct A_l from phi_l symbolically
        
slide 14:
    - copy A_l
    - new starting state, for each character in S_{l-1} add another state (see what that does in a second)
    - quantified last variable
        -> only l-1 natural numbers to plug in
        -> want A_{l-1} to behave like phi_{l-1} = accept l-1 natural numbers if there is another natural number which you can plug in for the quantified variable so that the formula becomes true

slide 17
    - terminology (basically an automaton with an additional band for reading / writing)
    - record (old state, transition, new state) triples -> computation history
    
slide 18
    - theorem word problem and existence of mapping reduction need to be accepted
      but are not too hard to imagine
      
slide 19
    - sentences are either true or false, proof shows: there are some statements that are undecidable
    -> are these true or false?
    -> should we not be able to prove them?
    
slide 22
    - in our proof, this statement was rather 
      "This is a statement which you (dear Turing machine) cannot prove because it would break your logic."

maybe for discussion:
Riemann hypothesis: all zeros of Riemann zeta function are in {.5 + i a | a \in |R}
map problem to a sentence phi in Th(|N, +, x) and simultaneously try to proof both phi and \neg phi

suppose phi undecidable

suppose false, then provably false (find a zero off the line, construction / search)
-> decidable
-> it can't be false
-> it is true but unprovable

So proving that the Riemann hypothesis is undecidable would show that it must be true.
-> That would mean, one would prove it's true by showing it has no proof.
-> Contradiction? :p
